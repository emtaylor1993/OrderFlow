package com.orderflow.orderservice.entity;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import com.orderflow.orderservice.domain.OrderState;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OrderBy;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

/**
 * ORDER ENTITY CLASS
 * - Represents an Order in the database and is the parent ("aggregate") of its line items.
 * - Stores "snapshot" totals in cents so API responses are stable over time.
 * - Uses idempotencyKey to prevent duplicate order creation when clients retry requests.
 * - AccessLevel.PROTECTED on no-args constructor to prevent direct instantiation without using the builder or factory methods.
 * - EqualsAnndHashCode(onlyExplicitlyIncluded = true) to avoid equals/hashCode on all fields.
 * - ToString(exclude = "lineItems") to avoid recursive toString() calls.
 * 
 * @author Emmanuel Taylor
 */
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(exclude = "lineItems")
@Entity
@Table(name = "orders")
public class Order {

    /** Primary key. UUID was chosen for its uniqueness across distributed/event-driven systems.
     *  It is also safer for Kafka/Event IDs. Generated by Hibernate using the UUID strategy. */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", nullable = false, updatable = false)
    @EqualsAndHashCode.Include
    private UUID id;

    /** Idempotency key. If the client retries the same create request, it will be detected and
     *  the same order will be returned instead of creating a duplicate. Updatable set to false
     *  to prevent accidental changes after insertion. */
    @Column(name = "idempotency_key", nullable = false, unique = true, updatable = false)
    private String idempotencyKey;

    /** Optional external reference. (Cart ID, UI Session ID, etc.) */
    @Column(name = "reference_id")
    private String referenceId;

    /** Order lifecycle state. Stored as a String enum so that database values remain readable
     *  and stable if enum ordering changes. */
    @Enumerated(EnumType.STRING)
    @Column(name = "state", nullable = false)
    private OrderState state;

    /** Optional note about the order from the client. */
    @Column(name = "note")
    private String note;

    /** ISO currency code (3 chars). Updated set to false to keep currency immutable. */
    @Column(name = "currency", nullable = false, length = 3, updatable = false)
    private String currency = "USD";

    /** 
     * Stored totals (in cents). These are persisted to keep responses stable and avoid
     * recomputing with potentially changing rules later.
     */
    @Column(name = "subtotal_amount", nullable = false)
    private long subtotalAmount = 0L;

    @Column(name = "total_discount_amount", nullable = false)
    private long totalDiscountAmount = 0L;

    @Column(name = "total_amount", nullable = false)
    private long totalAmount = 0L;

    @Column(name = "total_tax_amount", nullable = false)
    private long totalTaxAmount = 0L;

    /** Automatically set on insertion by Hibernate. */
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private OffsetDateTime createdAt;

    /** Automated updated on insert/update by Hibernate. */
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;

    /**
     * Order -> LineItems (1:N relationship).
     * mappedBy="order" indicates that OrderLineItem owns the foreign key (order_id).
     * CascadeType.ALL means that persisting/updating/deleting an Order will cascade to its LineItems.
     * orphanRemoval=true means removing an item from the list deletes it from the database.
     * FetchType.LAZY means line items are loaded on demand instead of all at once.
     */
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @OrderBy("lineNumber ASC")
    private List<OrderLineItem> lineItems = new ArrayList<>();

    /**
     * Adds a LineItem while keeping the bidirectional relationship in sync.
     * 
     * @param item The OrderLineItem to add to this Order.
     */
    public void addLineItem(OrderLineItem item) {
        item.setOrder(this);
        if (item.getLineNumber() <= 0) {
            item.setLineNumber(lineItems.size() + 1);
        }
        lineItems.add(item);
    }

    /**
     * Removes a lineItem and resequences the remaining line numbers to keep them contiguous.
     * 
     * @param item The OrderLineItem to remove from this Order.
     */
    public void removeLineItem(OrderLineItem item) {
        lineItems.remove(item);
        item.setOrder(null);
        resequenceLineNumbers();
    }

    /**
     * Keeps lineNumber valuse contiguous (1..N).
     * This avoids gaps after deletes and keeps ordering predictable.
     */
    public void resequenceLineNumbers() {
        for (int i = 0; i < lineItems.size(); i++) {
            lineItems.get(i).setLineNumber(i + 1);
        }
    }
}
